# Bot Planner Behavior

This document summarizes how the bot planner evaluates positions, generates action plans, and chooses a move.

## 1. Overview

The bot planner builds a set of candidate action sequences for the current turn, simulates them, scores the resulting states, and chooses the best sequence based on personality and optional randomness. It can look ahead across multiple of its own turns.

## 2. State Scoring

The current scoring heuristic is in `score_state`:

- VP is the core signal.
- Resources and tokens are valued at roughly 5 resources = 1 VP.
- Weapons are valued by total fight cost reduction times remaining uses.
- Upgrades are valued by their cost (as engine value) minus VP.
- Wounds impose a penalty (steeper after 5 and 10 wounds).
- Slots are valued lightly, with a higher weight on occupied slots.

The score is a single number used to compare plans.

## 3. Planning Loop

- The planner simulates up to `max_depth` of the bot's own future turns.
- For each turn, it enumerates possible plans (action sequences), simulates them, and stores a score snapshot after each action.
- It keeps the top N plans at each depth to limit branching.
- After each plan, it advances the game to the bot's next turn by simulating opponents.

## 4. Action Enumeration (One Turn)

Plans are built by combining these blocks in order:

1. Optional buy sequence (buy upgrade or weapon, with optional conversion and slot extension).
2. Optional upgrade activations (mass token or split conversion).
3. One main action:
   - Fight (generated by evaluating attackable threats).
   - Realign (stance change).
   - Pick a token.
   - End turn (fallback).

Each plan is a flat list of actions executed in order.

## 5. Fight Generation

For each attackable threat:

- The bot enumerates playable weapon subsets (up to size 3).
- For each subset, it builds a fight payload and computes the adjusted cost.
- If the cost is unaffordable, it considers conversion token usage.
- It keeps the cheapest candidate per target.

This produces a set of fight sequences such as:

- `[fight]`
- `[convert, fight]`

## 6. Free Stance Change Branching

Some fights grant a free stance change (for example, Neural Spike on kill). When this happens during plan simulation:

- After executing the plan, if the bot still has the turn and `free_stance_changes > 0`, the planner branches.
- It keeps a "no change" branch and creates one branch per alternate stance.
- Each branch executes a free `realign` action and then ends the turn.
- The best branch is selected by score, so the bot will use the free stance change when it improves the next position.

This ensures free stance changes are explored whenever they become available after a planned event.

## 7. Personality and Randomness

- `personality` selects how the final plan is chosen among top candidates.
- `randomness` adds noise to scores to reduce deterministic play and avoid local maxima.

## 8. Limits and Practical Tradeoffs

- Branching is capped by `top_n` and `max_depth`.
- The planner evaluates its own turns, not full game trees.
- Scores are heuristic, so specific card interactions may not be captured unless the scoring model is extended.

## 9. Key Files

- `backend/app/bot_planner.py`: planner, scoring, and action enumeration.
- `game_core/session.py`: actual action rules and effects.
- `backend/app/bot_simulation_router.py`: drives simulation runs and captures stats.
